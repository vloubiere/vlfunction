#' Import contributions object
#'
#' @param h5 A vector of paths to h5 file(s) containing the contribution scores.
#' @param bed Bed file(s) containing the regions for which contributions were computed. By default, the file is searched in the same folder as the h5 file.
#' @param fa fasta file(s) containing the sequences for which contributions were computed. By default, the file is searched in the same folder as the h5 file.
#'
#' @return A contribution data.table containing, for each region, the contribution scores (as list) and the corresponding sequence.
#' @export
#'
#' @examples
vl_importContrib <- function(h5,
                             bed= list.files(dirname(h5), ".bed$", full.names = TRUE),
                             fa= list.files(dirname(h5), ".fa$", full.names = TRUE))
{
  # Metadata ----
  meta <- data.table(h5= h5, bed= bed, fa= fa)
  
  # Import ----
  dat <- meta[, {
    # bed regions
    .c <- vl_importBed(bed)
    if(!is.na(fa) && file.exists(fa))
      .c$seq <- as.character(seqinr::read.fasta(fa, as.string = TRUE)) else
        message("No valid fasta file found")
    if(!is.na(h5) && file.exists(h5))
    {
      .h <- rhdf5::h5read(h5, "contrib_scores/class")
      .c$score <- lapply(seq(dim(.h)[3]), function(i) rowSums(.h[,,i]))
    }else
      message("No valid h5 file found")
    .c
  }, .(h5, bed, fa)]
  dat$h5 <- dat$bed <- dat$fa <- NULL
  
  # Message ----
  if(any(nchar(dat$seq)>20))
  {
    options(datatable.prettyprint.char = 10)
    message("Printing option set to 10. To reset it to default, use options(datatable.prettyprint.char = NULL)")
  }

  # Return object ----
  return(dat)
}

#' Add motif columns to contribution object
#'
#' @param contrib A contribution object generated by ?vl_importContrib()
#' @param sel A selection of motif_IDs. Default= vl_motifs_DB_v2[collection=="jaspar", motif_ID]
#' @param motifDB The motifDB to be used. Default= vl_motifs_DB_v2
#' @param p.cutoff The cutoff to be used for calling motifs. Default= 5e-5
#' @param genome The genome to be used
#' @param bg background. Default= "genome".
#'
#' @return A contribution data.table containing, for each motif_ID, a vector corresponding to its matches.
#' @export
#'
#' @examples
vl_contrib_addMotif <- function(contrib,
                                sel = vl_motifs_DB_v2[collection=="jaspar", motif_ID],
                                motifDB = vl_motifs_DB_v2,
                                p.cutoff = 5e-5,
                                genome,
                                bg = "genome")
{
  # Compute motif position ----
  pos <- vl_motif_pos(contrib$seq,
                      sel = sel,
                      motifDB = motifDB,
                      bg = bg,
                      genome = genome,
                      p.cutoff = p.cutoff,
                      collapse.overlapping = FALSE)
  
  # Parse object ----
  pos <- lapply(pos, function(x) {
    lapply(x, function(y) {
      .c <- as.data.table(y)
      if(nrow(.c))
        unique(.c[, .(start:end), .(start, end)]$V1) else
          as.integer(NA)
    })
  })
  
  # Add to data ----
  pos <- as.data.table(pos)
  contrib <- cbind(contrib, pos)
  
  # Return ----
  contrib
}

#' Plot contribution scores matrix
#'
#' @param bed A bed file containing a unique region for which contrib scores will be plotted.
#' @param h5 Path(s) to h5 files containing the contribution scores.
#' @param h5.bed Bed files containing the coordinates of the regions corresponding to provided h5 files.
#' @param genome The genome to be used.
#' @param agg.FUN In the case were several contribution scores would be found for a single nt, how should they be aggregated? Default= function(x) mean(x)
#' @param mot An optional bed file containing motifs to be added.
#' @param mot.name.column Name of the column containing the motif name.
#' @param xlab Default= "nt"
#' @param ylab Default= "Contribution"
#' @param xlim Default= sequence length
#' @param ylim Default= range(contrib)
#'
#' @return contrib plot
#' @export
vl_plot_contrib_logo <- function(bed,
                                 h5,
                                 h5.bed= list.files(dirname(h5), ".bed$", full.names = TRUE),
                                 h5.fa= list.files(dirname(h5), ".fa$", full.names = TRUE),
                                 genome,
                                 agg.FUN= function(x) mean(x),
                                 mot,
                                 mot.name.column= "motif_ID",
                                 xlab= "nt",
                                 ylab= "Contribution",
                                 xlim,
                                 ylim)
{
  # Import Bed
  bed <- vl_importBed(bed) # Very important!
  if(nrow(bed)>1)
    stop("Unique region should be specified")
  
  browser()
  # Metadata ----
  dat <- vl_importContrib(h5,
                          bed= h5.bed,
                          fa= h5.fa)
  
  # Intersect ----
  region <- dat[bed, on= c("seqnames", "start<=end", "end>=start")]
  
  
  # # Import contribution scores ----
  # dat <- meta[, {
  #   vl_importContrib(h5,
  #                    bed = h5.bed,
  #                    selection= bed)
  # }, .(h5, h5.bed)]
  # 
  # # Aggregate if necessary ----
  # if(uniqueN(dat[, .(seqnames, start)]) != nrow(dat))
  # {
  #   message("Some nucleotides had >1 contribution score assigned to it, which will be aggregated using agg.FUN")
  #   dat <- dat[, .(score= agg.FUN(score)), .(seqnames, start, end)]
  # }
  # 
  # # Get sequence ----
  # dat$base <- strsplit(vl_getSequence(bed, genome), "")[[1]]
  # 
  # # Plotting vars ----
  # dat[, xleft:= .I-1]
  # if(missing(xlim))
  #   xlim <- c(0, nrow(dat))
  # if(missing(ylim))
  #   ylim <- range(dat$score)
  # 
  # # Plotting ----
  # plot(NA,
  #      xlim= xlim,
  #      ylim= ylim,
  #      xlab= xlab,
  #      ylab= ylab,
  #      frame= FALSE)
  # 
  # dat[, {
  #   vl_plotLetter(base,
  #                 xleft = xleft,
  #                 ytop= score,
  #                 width = 1,
  #                 height = score)
  # }, (dat)]
  # 
  # # Add motif boxes ----
  # if(!missing(mot))
  # {
  #   mot <- vl_importBed(mot)
  #   mot <- vl_intersectBed(mot, bed, ignore.strand= TRUE)
  #   if(nrow(mot))
  #     mot[, {
  #       xl <- start-bed$start
  #       xr <- end-bed$start
  #       rect(xleft = xl,
  #            ybottom = ylim[1],
  #            xright = xr,
  #            ytop = ylim[2])
  #       text((xl+xr)/2,
  #            ylim[2],
  #            get(mot.name.column)[1],
  #            pos= 3,
  #            xpd= T)
  #     }, (mot)]
  # }
}


