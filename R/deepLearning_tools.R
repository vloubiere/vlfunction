#' Import contributions object
#'
#' @param h5 A vector of paths to h5 file(s) containing the contribution scores.
#' @param bed Bed file(s) containing the regions for which contributions were computed. By default, the file is searched in the same folder as the h5 file.
#' @param fa fasta file(s) containing the sequences for which contributions were computed. By default, the file is searched in the same folder as the h5 file.
#'
#' @return A contribution data.table containing, for each region, the contribution scores (as list) and the corresponding sequence.
#' @export
#'
#' @examples
#' dat <- vl_importContrib(h5= list.files("db/model_PH18/contributions/", "h5$", recursive = TRUE, full.names = TRUE))
#' 
vl_importContrib <- function(h5,
                             bed= list.files(dirname(h5), ".bed$", full.names = TRUE),
                             fa= list.files(dirname(h5), ".fa$", full.names = TRUE))
{
  # Metadata ----
  meta <- data.table(h5= h5, bed= bed, fa= fa)
  
  # Import ----
  dat <- meta[, {
    # bed regions
    .c <- vl_importBed(bed)
    if(!is.na(fa) && file.exists(fa))
      .c$seq <- as.character(seqinr::read.fasta(fa, as.string = TRUE)) else
        message("No valid fasta file found")
    if(!is.na(h5) && file.exists(h5))
    {
      .h <- rhdf5::h5read(h5, "contrib_scores/class")
      .c$score <- lapply(seq(dim(.h)[3]), function(i) rowSums(.h[,,i]))
    }else
      message("No valid h5 file found")
    .c
  }, .(h5, bed, fa)]
  dat$h5 <- dat$bed <- dat$fa <- NULL
  
  # Message ----
  if(any(nchar(dat$seq)>20))
  {
    options(datatable.prettyprint.char = 10)
    message("Printing option set to 10. To reset it to default, use options(datatable.prettyprint.char = NULL)")
  }

  # Return object ----
  return(dat)
}

#' Add motif columns to contribution object
#'
#' @param contrib A contribution object generated by ?vl_importContrib()
#' @param pwm_log_odds A list of pwms (log_odds) for which matchin positions should be returned.
#' @param motifDB The motifDB to be used. Default= vl_motifs_DB_v2
#' @param p.cutoff The cutoff to be used for calling motifs. Default= 5e-5
#' @param genome The genome to be used
#' @param bg background. Default= "genome".
#'
#' @return A contribution data.table containing, for each motif_ID, a vector corresponding to its matches.
#' @export
#'
#' @examples
#' dat <- vl_importContrib(h5= list.files("db/model_PH18/contributions/", "h5$", recursive = TRUE, full.names = TRUE))
#' mot <- vl_contrib_addMotif(dat, p.cutoff= 1e-4, genome= "dm6")
#' 
vl_contrib_addMotif <- function(contrib,
                                pwm_log_odds= vl_motifs_DB_v2[collection=="jaspar", pwms_log_odds],
                                p.cutoff = 5e-5,
                                genome,
                                bg = "genome")
{
  # Compute motif position ----
  pos <- vl_motif_pos(contrib$seq,
                      pwm_log_odds = pwm_log_odds,
                      bg = bg,
                      genome = genome,
                      p.cutoff = p.cutoff,
                      collapse.overlapping = TRUE)
  
  # Add to data ----
  pos <- as.data.table(pos)
  contrib <- cbind(contrib, pos)
  
  # Return ----
  return(contrib)
}

#' Compute enrichment for each motif instance
#'
#' @param obj
#'
#' @return
#' @export
vl_contrib_enrich <- function(obj= vl_PH18_contrib,
                              mot_columns= NULL)
{
  # Retrieve motif columns ----
  if(is.null(mot_columns))
  {
    check <- sapply(obj, class)
    mot_columns <- setdiff(names(obj)[check=="list"], "score")
  }
  
  # Melt object ----
  res <- melt(obj,
              id.vars = "score",
              measure.vars = mot_columns)
  mot <- rbindlist(res$value, fill= TRUE)
  mot[, seq.idx:= as.numeric(seqnames)]
  mot[, bg.scores:= obj[(seq.idx), score]]
  mot[, mot.scores:= .(lapply(bg.scores, function(x) x[start:end])), .(start, end)]
  
  # Compute pvalues ----
  mot[, mot.idx:= .I]
  mot$pval <- parallel::mcmapply(function(mot, bg){
    wilcox.test(mot.scores[[1]], bg.scores[[1]], alternative= "greater")$p.value
  },
  mc.preschedule = FALSE,
  mc.cores = data.table::getDTthreads()-1,
  mot= mot$mot.scores,
  bg= mot$bg.scores)
  mot[, pval:= wilcox.test(mot.scores[[1]], bg.scores[[1]], alternative= "greater")$p.value, mot.idx]
  
  # Extract contribution scores ----
  
  obj$seqname
  mot <- rbindlist(res[sapply(res$value, nrow)>0, value],
                   fill= TRUE)
  mot <- res[sapply(res$value, nrow)>0]
  mot[, idx:= .I]
  mot <- mot[, value[[1]][, test:= score], .(variable, idx)]
  
  res[lengths(value)<3, pval:= NA]
  res[!is.na(pval), pval:= wilcox.test()]
  # 
  # res <- parallel::mcmapply(function(mot, bg) {
  # res <- mapply(function(mot, bg) {
  #   check <- lengths(mot)>=3 # Compute pval if at least 3nt
  #   pval <- rep(NA, length(mot))
  #   browser()
  #   pval[(check)] <- mapply(function(x, y)
  #   {
  #     wilcox.test(x, y, alternative = "greater")$p.value
  #   },
  #   x= mot[(check)],
  #   y= bg[(check)],
  #   SIMPLIFY = TRUE)
  # },
  # mot= as.list(obj[, mot_columns, with= F])[1:2],
  # bg= as.list(obj[, .(score)]))
  # 
  # 
  #   mot_columns <- 
  # means <- sapply(obj$score, mean)
  
         
}

#' Plot contribution scores matrix
#'
#' @param bed A bed file containing a unique region for which contrib scores will be plotted.
#' @param h5 Path(s) to h5 files containing the contribution scores.
#' @param h5.bed Bed files containing the coordinates of the regions corresponding to provided h5 files.
#' @param genome The genome to be used.
#' @param agg.FUN In the case were several contribution scores would be found for a single nt, how should they be aggregated? Default= function(x) mean(x)
#' @param mot An optional bed file containing motifs to be added.
#' @param mot.name.column Name of the column containing the motif name.
#' @param xlab Default= "nt"
#' @param ylab Default= "Contribution"
#' @param xlim Default= sequence length
#' @param ylim Default= range(contrib)
#'
#' @export
#' @return contrib plot
#' 
vl_plot_contrib_logo <- function(bed,
                                 h5,
                                 h5.bed= list.files(dirname(h5), ".bed$", full.names = TRUE),
                                 h5.fa= list.files(dirname(h5), ".fa$", full.names = TRUE),
                                 genome,
                                 agg.FUN= function(x) mean(x),
                                 mot,
                                 mot.name.column= "motif_ID",
                                 xlab= "nt",
                                 ylab= "Contribution",
                                 xlim,
                                 ylim)
{
  # Import Bed
  bed <- vl_importBed(bed) # Very important!
  if(nrow(bed)>1)
    stop("Unique region should be specified")
  
  browser()
  # Metadata ----
  dat <- vl_importContrib(h5,
                          bed= h5.bed,
                          fa= h5.fa)
  
  # Intersect ----
  region <- dat[bed, on= c("seqnames", "start<=end", "end>=start")]
  
  
  # # Import contribution scores ----
  # dat <- meta[, {
  #   vl_importContrib(h5,
  #                    bed = h5.bed,
  #                    selection= bed)
  # }, .(h5, h5.bed)]
  # 
  # # Aggregate if necessary ----
  # if(uniqueN(dat[, .(seqnames, start)]) != nrow(dat))
  # {
  #   message("Some nucleotides had >1 contribution score assigned to it, which will be aggregated using agg.FUN")
  #   dat <- dat[, .(score= agg.FUN(score)), .(seqnames, start, end)]
  # }
  # 
  # # Get sequence ----
  # dat$base <- strsplit(vl_getSequence(bed, genome), "")[[1]]
  # 
  # # Plotting vars ----
  # dat[, xleft:= .I-1]
  # if(missing(xlim))
  #   xlim <- c(0, nrow(dat))
  # if(missing(ylim))
  #   ylim <- range(dat$score)
  # 
  # # Plotting ----
  # plot(NA,
  #      xlim= xlim,
  #      ylim= ylim,
  #      xlab= xlab,
  #      ylab= ylab,
  #      frame= FALSE)
  # 
  # dat[, {
  #   vl_plotLetter(base,
  #                 xleft = xleft,
  #                 ytop= score,
  #                 width = 1,
  #                 height = score)
  # }, (dat)]
  # 
  # # Add motif boxes ----
  # if(!missing(mot))
  # {
  #   mot <- vl_importBed(mot)
  #   mot <- vl_intersectBed(mot, bed, ignore.strand= TRUE)
  #   if(nrow(mot))
  #     mot[, {
  #       xl <- start-bed$start
  #       xr <- end-bed$start
  #       rect(xleft = xl,
  #            ybottom = ylim[1],
  #            xright = xr,
  #            ytop = ylim[2])
  #       text((xl+xr)/2,
  #            ylim[2],
  #            get(mot.name.column)[1],
  #            pos= 3,
  #            xpd= T)
  #     }, (mot)]
  # }
}


